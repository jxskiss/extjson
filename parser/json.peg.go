package parser

// Code generated by peg -output ./parser/json.peg.go json.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleDocument
	ruleJSON
	ruleObject
	ruleObjectKey
	ruleArray
	ruleDirective
	ruleInclude
	ruleRefer
	ruleSimpleIdentifier
	ruleString
	ruleSingleQuoteLiteral
	ruleDoubleQuoteLiteral
	ruleSingleQuoteEscape
	ruleDoubleQuoteEscape
	ruleUnicodeEscape
	ruleHexDigit
	ruleTrue
	ruleFalse
	ruleNull
	ruleNumber
	ruleMinus
	ruleIntegralPart
	ruleFractionalPart
	ruleExponentPart
	ruleSpacing
	ruleWhitespace
	ruleLongComment
	ruleLineComment
	rulePragma
	ruleLWING
	ruleRWING
	ruleLBRK
	ruleRBRK
	ruleCOMMA
	ruleCOLON
	ruleEOT
)

var rul3s = [...]string{
	"Unknown",
	"Document",
	"JSON",
	"Object",
	"ObjectKey",
	"Array",
	"Directive",
	"Include",
	"Refer",
	"SimpleIdentifier",
	"String",
	"SingleQuoteLiteral",
	"DoubleQuoteLiteral",
	"SingleQuoteEscape",
	"DoubleQuoteEscape",
	"UnicodeEscape",
	"HexDigit",
	"True",
	"False",
	"Null",
	"Number",
	"Minus",
	"IntegralPart",
	"FractionalPart",
	"ExponentPart",
	"Spacing",
	"Whitespace",
	"LongComment",
	"LineComment",
	"Pragma",
	"LWING",
	"RWING",
	"LBRK",
	"RBRK",
	"COMMA",
	"COLON",
	"EOT",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type JSON struct {
	Buffer string
	buffer []rune
	rules  [37]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *JSON) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *JSON) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *JSON
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *JSON) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *JSON) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *JSON) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*JSON) error {
	return func(p *JSON) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*JSON) error {
	return func(p *JSON) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *JSON) Init(options ...func(*JSON) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Document <- <(Spacing JSON EOT)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpacing]() {
					goto l0
				}
				if !_rules[ruleJSON]() {
					goto l0
				}
				if !_rules[ruleEOT]() {
					goto l0
				}
				add(ruleDocument, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 JSON <- <((Object / Array / String / True / False / Null / Number / Directive) Spacing)> */
		func() bool {
			position2, tokenIndex2 := position, tokenIndex
			{
				position3 := position
				{
					position4, tokenIndex4 := position, tokenIndex
					if !_rules[ruleObject]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleArray]() {
						goto l6
					}
					goto l4
				l6:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleString]() {
						goto l7
					}
					goto l4
				l7:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleTrue]() {
						goto l8
					}
					goto l4
				l8:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleFalse]() {
						goto l9
					}
					goto l4
				l9:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleNull]() {
						goto l10
					}
					goto l4
				l10:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleNumber]() {
						goto l11
					}
					goto l4
				l11:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDirective]() {
						goto l2
					}
				}
			l4:
				if !_rules[ruleSpacing]() {
					goto l2
				}
				add(ruleJSON, position3)
			}
			return true
		l2:
			position, tokenIndex = position2, tokenIndex2
			return false
		},
		/* 2 Object <- <(LWING (ObjectKey COLON JSON COMMA)* (ObjectKey COLON JSON)? RWING)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[ruleLWING]() {
					goto l12
				}
			l14:
				{
					position15, tokenIndex15 := position, tokenIndex
					if !_rules[ruleObjectKey]() {
						goto l15
					}
					if !_rules[ruleCOLON]() {
						goto l15
					}
					if !_rules[ruleJSON]() {
						goto l15
					}
					if !_rules[ruleCOMMA]() {
						goto l15
					}
					goto l14
				l15:
					position, tokenIndex = position15, tokenIndex15
				}
				{
					position16, tokenIndex16 := position, tokenIndex
					if !_rules[ruleObjectKey]() {
						goto l16
					}
					if !_rules[ruleCOLON]() {
						goto l16
					}
					if !_rules[ruleJSON]() {
						goto l16
					}
					goto l17
				l16:
					position, tokenIndex = position16, tokenIndex16
				}
			l17:
				if !_rules[ruleRWING]() {
					goto l12
				}
				add(ruleObject, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 ObjectKey <- <(String / SimpleIdentifier)> */
		func() bool {
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				{
					position20, tokenIndex20 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position20, tokenIndex20
					if !_rules[ruleSimpleIdentifier]() {
						goto l18
					}
				}
			l20:
				add(ruleObjectKey, position19)
			}
			return true
		l18:
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 4 Array <- <(LBRK (JSON COMMA)* JSON? RBRK)> */
		func() bool {
			position22, tokenIndex22 := position, tokenIndex
			{
				position23 := position
				if !_rules[ruleLBRK]() {
					goto l22
				}
			l24:
				{
					position25, tokenIndex25 := position, tokenIndex
					if !_rules[ruleJSON]() {
						goto l25
					}
					if !_rules[ruleCOMMA]() {
						goto l25
					}
					goto l24
				l25:
					position, tokenIndex = position25, tokenIndex25
				}
				{
					position26, tokenIndex26 := position, tokenIndex
					if !_rules[ruleJSON]() {
						goto l26
					}
					goto l27
				l26:
					position, tokenIndex = position26, tokenIndex26
				}
			l27:
				if !_rules[ruleRBRK]() {
					goto l22
				}
				add(ruleArray, position23)
			}
			return true
		l22:
			position, tokenIndex = position22, tokenIndex22
			return false
		},
		/* 5 Directive <- <(Include / Refer)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				{
					position30, tokenIndex30 := position, tokenIndex
					if !_rules[ruleInclude]() {
						goto l31
					}
					goto l30
				l31:
					position, tokenIndex = position30, tokenIndex30
					if !_rules[ruleRefer]() {
						goto l28
					}
				}
			l30:
				add(ruleDirective, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 6 Include <- <('@' 'i' 'n' 'c' 'l' '(' String ')')> */
		func() bool {
			position32, tokenIndex32 := position, tokenIndex
			{
				position33 := position
				if buffer[position] != rune('@') {
					goto l32
				}
				position++
				if buffer[position] != rune('i') {
					goto l32
				}
				position++
				if buffer[position] != rune('n') {
					goto l32
				}
				position++
				if buffer[position] != rune('c') {
					goto l32
				}
				position++
				if buffer[position] != rune('l') {
					goto l32
				}
				position++
				if buffer[position] != rune('(') {
					goto l32
				}
				position++
				if !_rules[ruleString]() {
					goto l32
				}
				if buffer[position] != rune(')') {
					goto l32
				}
				position++
				add(ruleInclude, position33)
			}
			return true
		l32:
			position, tokenIndex = position32, tokenIndex32
			return false
		},
		/* 7 Refer <- <('@' 'r' 'e' 'f' '(' ' ' 'S' 't' 'r' 'i' 'n' 'g' ' ' ')')> */
		func() bool {
			position34, tokenIndex34 := position, tokenIndex
			{
				position35 := position
				if buffer[position] != rune('@') {
					goto l34
				}
				position++
				if buffer[position] != rune('r') {
					goto l34
				}
				position++
				if buffer[position] != rune('e') {
					goto l34
				}
				position++
				if buffer[position] != rune('f') {
					goto l34
				}
				position++
				if buffer[position] != rune('(') {
					goto l34
				}
				position++
				if buffer[position] != rune(' ') {
					goto l34
				}
				position++
				if buffer[position] != rune('S') {
					goto l34
				}
				position++
				if buffer[position] != rune('t') {
					goto l34
				}
				position++
				if buffer[position] != rune('r') {
					goto l34
				}
				position++
				if buffer[position] != rune('i') {
					goto l34
				}
				position++
				if buffer[position] != rune('n') {
					goto l34
				}
				position++
				if buffer[position] != rune('g') {
					goto l34
				}
				position++
				if buffer[position] != rune(' ') {
					goto l34
				}
				position++
				if buffer[position] != rune(')') {
					goto l34
				}
				position++
				add(ruleRefer, position35)
			}
			return true
		l34:
			position, tokenIndex = position34, tokenIndex34
			return false
		},
		/* 8 SimpleIdentifier <- <([0-9] / [A-Z] / [a-z] / '_' / '$')+> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
				{
					position40, tokenIndex40 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l41
					}
					position++
					goto l40
				l41:
					position, tokenIndex = position40, tokenIndex40
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l42
					}
					position++
					goto l40
				l42:
					position, tokenIndex = position40, tokenIndex40
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l43
					}
					position++
					goto l40
				l43:
					position, tokenIndex = position40, tokenIndex40
					if buffer[position] != rune('_') {
						goto l44
					}
					position++
					goto l40
				l44:
					position, tokenIndex = position40, tokenIndex40
					if buffer[position] != rune('$') {
						goto l36
					}
					position++
				}
			l40:
			l38:
				{
					position39, tokenIndex39 := position, tokenIndex
					{
						position45, tokenIndex45 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l46
						}
						position++
						goto l45
					l46:
						position, tokenIndex = position45, tokenIndex45
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l47
						}
						position++
						goto l45
					l47:
						position, tokenIndex = position45, tokenIndex45
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l48
						}
						position++
						goto l45
					l48:
						position, tokenIndex = position45, tokenIndex45
						if buffer[position] != rune('_') {
							goto l49
						}
						position++
						goto l45
					l49:
						position, tokenIndex = position45, tokenIndex45
						if buffer[position] != rune('$') {
							goto l39
						}
						position++
					}
				l45:
					goto l38
				l39:
					position, tokenIndex = position39, tokenIndex39
				}
				add(ruleSimpleIdentifier, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 9 String <- <(SingleQuoteLiteral / DoubleQuoteLiteral)> */
		func() bool {
			position50, tokenIndex50 := position, tokenIndex
			{
				position51 := position
				{
					position52, tokenIndex52 := position, tokenIndex
					if !_rules[ruleSingleQuoteLiteral]() {
						goto l53
					}
					goto l52
				l53:
					position, tokenIndex = position52, tokenIndex52
					if !_rules[ruleDoubleQuoteLiteral]() {
						goto l50
					}
				}
			l52:
				add(ruleString, position51)
			}
			return true
		l50:
			position, tokenIndex = position50, tokenIndex50
			return false
		},
		/* 10 SingleQuoteLiteral <- <('\'' (SingleQuoteEscape / (!('\'' / '\\' / '\n' / '\r') .))* '\'')> */
		func() bool {
			position54, tokenIndex54 := position, tokenIndex
			{
				position55 := position
				if buffer[position] != rune('\'') {
					goto l54
				}
				position++
			l56:
				{
					position57, tokenIndex57 := position, tokenIndex
					{
						position58, tokenIndex58 := position, tokenIndex
						if !_rules[ruleSingleQuoteEscape]() {
							goto l59
						}
						goto l58
					l59:
						position, tokenIndex = position58, tokenIndex58
						{
							position60, tokenIndex60 := position, tokenIndex
							{
								position61, tokenIndex61 := position, tokenIndex
								if buffer[position] != rune('\'') {
									goto l62
								}
								position++
								goto l61
							l62:
								position, tokenIndex = position61, tokenIndex61
								if buffer[position] != rune('\\') {
									goto l63
								}
								position++
								goto l61
							l63:
								position, tokenIndex = position61, tokenIndex61
								if buffer[position] != rune('\n') {
									goto l64
								}
								position++
								goto l61
							l64:
								position, tokenIndex = position61, tokenIndex61
								if buffer[position] != rune('\r') {
									goto l60
								}
								position++
							}
						l61:
							goto l57
						l60:
							position, tokenIndex = position60, tokenIndex60
						}
						if !matchDot() {
							goto l57
						}
					}
				l58:
					goto l56
				l57:
					position, tokenIndex = position57, tokenIndex57
				}
				if buffer[position] != rune('\'') {
					goto l54
				}
				position++
				add(ruleSingleQuoteLiteral, position55)
			}
			return true
		l54:
			position, tokenIndex = position54, tokenIndex54
			return false
		},
		/* 11 DoubleQuoteLiteral <- <('"' (DoubleQuoteEscape / (!('"' / '\\' / '\n' / '\r') .))* '"')> */
		func() bool {
			position65, tokenIndex65 := position, tokenIndex
			{
				position66 := position
				if buffer[position] != rune('"') {
					goto l65
				}
				position++
			l67:
				{
					position68, tokenIndex68 := position, tokenIndex
					{
						position69, tokenIndex69 := position, tokenIndex
						if !_rules[ruleDoubleQuoteEscape]() {
							goto l70
						}
						goto l69
					l70:
						position, tokenIndex = position69, tokenIndex69
						{
							position71, tokenIndex71 := position, tokenIndex
							{
								position72, tokenIndex72 := position, tokenIndex
								if buffer[position] != rune('"') {
									goto l73
								}
								position++
								goto l72
							l73:
								position, tokenIndex = position72, tokenIndex72
								if buffer[position] != rune('\\') {
									goto l74
								}
								position++
								goto l72
							l74:
								position, tokenIndex = position72, tokenIndex72
								if buffer[position] != rune('\n') {
									goto l75
								}
								position++
								goto l72
							l75:
								position, tokenIndex = position72, tokenIndex72
								if buffer[position] != rune('\r') {
									goto l71
								}
								position++
							}
						l72:
							goto l68
						l71:
							position, tokenIndex = position71, tokenIndex71
						}
						if !matchDot() {
							goto l68
						}
					}
				l69:
					goto l67
				l68:
					position, tokenIndex = position68, tokenIndex68
				}
				if buffer[position] != rune('"') {
					goto l65
				}
				position++
				add(ruleDoubleQuoteLiteral, position66)
			}
			return true
		l65:
			position, tokenIndex = position65, tokenIndex65
			return false
		},
		/* 12 SingleQuoteEscape <- <('\\' ('b' / 't' / 'n' / 'f' / 'r' / '\'' / '\\' / '/' / UnicodeEscape))> */
		func() bool {
			position76, tokenIndex76 := position, tokenIndex
			{
				position77 := position
				if buffer[position] != rune('\\') {
					goto l76
				}
				position++
				{
					position78, tokenIndex78 := position, tokenIndex
					if buffer[position] != rune('b') {
						goto l79
					}
					position++
					goto l78
				l79:
					position, tokenIndex = position78, tokenIndex78
					if buffer[position] != rune('t') {
						goto l80
					}
					position++
					goto l78
				l80:
					position, tokenIndex = position78, tokenIndex78
					if buffer[position] != rune('n') {
						goto l81
					}
					position++
					goto l78
				l81:
					position, tokenIndex = position78, tokenIndex78
					if buffer[position] != rune('f') {
						goto l82
					}
					position++
					goto l78
				l82:
					position, tokenIndex = position78, tokenIndex78
					if buffer[position] != rune('r') {
						goto l83
					}
					position++
					goto l78
				l83:
					position, tokenIndex = position78, tokenIndex78
					if buffer[position] != rune('\'') {
						goto l84
					}
					position++
					goto l78
				l84:
					position, tokenIndex = position78, tokenIndex78
					if buffer[position] != rune('\\') {
						goto l85
					}
					position++
					goto l78
				l85:
					position, tokenIndex = position78, tokenIndex78
					if buffer[position] != rune('/') {
						goto l86
					}
					position++
					goto l78
				l86:
					position, tokenIndex = position78, tokenIndex78
					if !_rules[ruleUnicodeEscape]() {
						goto l76
					}
				}
			l78:
				add(ruleSingleQuoteEscape, position77)
			}
			return true
		l76:
			position, tokenIndex = position76, tokenIndex76
			return false
		},
		/* 13 DoubleQuoteEscape <- <('\\' ('b' / 't' / 'n' / 'f' / 'r' / '"' / '\\' / '/' / UnicodeEscape))> */
		func() bool {
			position87, tokenIndex87 := position, tokenIndex
			{
				position88 := position
				if buffer[position] != rune('\\') {
					goto l87
				}
				position++
				{
					position89, tokenIndex89 := position, tokenIndex
					if buffer[position] != rune('b') {
						goto l90
					}
					position++
					goto l89
				l90:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('t') {
						goto l91
					}
					position++
					goto l89
				l91:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('n') {
						goto l92
					}
					position++
					goto l89
				l92:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('f') {
						goto l93
					}
					position++
					goto l89
				l93:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('r') {
						goto l94
					}
					position++
					goto l89
				l94:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('"') {
						goto l95
					}
					position++
					goto l89
				l95:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('\\') {
						goto l96
					}
					position++
					goto l89
				l96:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('/') {
						goto l97
					}
					position++
					goto l89
				l97:
					position, tokenIndex = position89, tokenIndex89
					if !_rules[ruleUnicodeEscape]() {
						goto l87
					}
				}
			l89:
				add(ruleDoubleQuoteEscape, position88)
			}
			return true
		l87:
			position, tokenIndex = position87, tokenIndex87
			return false
		},
		/* 14 UnicodeEscape <- <('u' HexDigit HexDigit HexDigit HexDigit)> */
		func() bool {
			position98, tokenIndex98 := position, tokenIndex
			{
				position99 := position
				if buffer[position] != rune('u') {
					goto l98
				}
				position++
				if !_rules[ruleHexDigit]() {
					goto l98
				}
				if !_rules[ruleHexDigit]() {
					goto l98
				}
				if !_rules[ruleHexDigit]() {
					goto l98
				}
				if !_rules[ruleHexDigit]() {
					goto l98
				}
				add(ruleUnicodeEscape, position99)
			}
			return true
		l98:
			position, tokenIndex = position98, tokenIndex98
			return false
		},
		/* 15 HexDigit <- <([a-f] / [A-F] / [0-9])> */
		func() bool {
			position100, tokenIndex100 := position, tokenIndex
			{
				position101 := position
				{
					position102, tokenIndex102 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('f') {
						goto l103
					}
					position++
					goto l102
				l103:
					position, tokenIndex = position102, tokenIndex102
					if c := buffer[position]; c < rune('A') || c > rune('F') {
						goto l104
					}
					position++
					goto l102
				l104:
					position, tokenIndex = position102, tokenIndex102
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l100
					}
					position++
				}
			l102:
				add(ruleHexDigit, position101)
			}
			return true
		l100:
			position, tokenIndex = position100, tokenIndex100
			return false
		},
		/* 16 True <- <(('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e'))> */
		func() bool {
			position105, tokenIndex105 := position, tokenIndex
			{
				position106 := position
				{
					position107, tokenIndex107 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l108
					}
					position++
					if buffer[position] != rune('r') {
						goto l108
					}
					position++
					if buffer[position] != rune('u') {
						goto l108
					}
					position++
					if buffer[position] != rune('e') {
						goto l108
					}
					position++
					goto l107
				l108:
					position, tokenIndex = position107, tokenIndex107
					if buffer[position] != rune('T') {
						goto l105
					}
					position++
					if buffer[position] != rune('r') {
						goto l105
					}
					position++
					if buffer[position] != rune('u') {
						goto l105
					}
					position++
					if buffer[position] != rune('e') {
						goto l105
					}
					position++
				}
			l107:
				add(ruleTrue, position106)
			}
			return true
		l105:
			position, tokenIndex = position105, tokenIndex105
			return false
		},
		/* 17 False <- <(('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e'))> */
		func() bool {
			position109, tokenIndex109 := position, tokenIndex
			{
				position110 := position
				{
					position111, tokenIndex111 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l112
					}
					position++
					if buffer[position] != rune('a') {
						goto l112
					}
					position++
					if buffer[position] != rune('l') {
						goto l112
					}
					position++
					if buffer[position] != rune('s') {
						goto l112
					}
					position++
					if buffer[position] != rune('e') {
						goto l112
					}
					position++
					goto l111
				l112:
					position, tokenIndex = position111, tokenIndex111
					if buffer[position] != rune('F') {
						goto l109
					}
					position++
					if buffer[position] != rune('a') {
						goto l109
					}
					position++
					if buffer[position] != rune('l') {
						goto l109
					}
					position++
					if buffer[position] != rune('s') {
						goto l109
					}
					position++
					if buffer[position] != rune('e') {
						goto l109
					}
					position++
				}
			l111:
				add(ruleFalse, position110)
			}
			return true
		l109:
			position, tokenIndex = position109, tokenIndex109
			return false
		},
		/* 18 Null <- <(('n' 'u' 'l' 'l') / ('N' 'o' 'n' 'e'))> */
		func() bool {
			position113, tokenIndex113 := position, tokenIndex
			{
				position114 := position
				{
					position115, tokenIndex115 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l116
					}
					position++
					if buffer[position] != rune('u') {
						goto l116
					}
					position++
					if buffer[position] != rune('l') {
						goto l116
					}
					position++
					if buffer[position] != rune('l') {
						goto l116
					}
					position++
					goto l115
				l116:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('N') {
						goto l113
					}
					position++
					if buffer[position] != rune('o') {
						goto l113
					}
					position++
					if buffer[position] != rune('n') {
						goto l113
					}
					position++
					if buffer[position] != rune('e') {
						goto l113
					}
					position++
				}
			l115:
				add(ruleNull, position114)
			}
			return true
		l113:
			position, tokenIndex = position113, tokenIndex113
			return false
		},
		/* 19 Number <- <(Minus? IntegralPart FractionalPart? ExponentPart?)> */
		func() bool {
			position117, tokenIndex117 := position, tokenIndex
			{
				position118 := position
				{
					position119, tokenIndex119 := position, tokenIndex
					if !_rules[ruleMinus]() {
						goto l119
					}
					goto l120
				l119:
					position, tokenIndex = position119, tokenIndex119
				}
			l120:
				if !_rules[ruleIntegralPart]() {
					goto l117
				}
				{
					position121, tokenIndex121 := position, tokenIndex
					if !_rules[ruleFractionalPart]() {
						goto l121
					}
					goto l122
				l121:
					position, tokenIndex = position121, tokenIndex121
				}
			l122:
				{
					position123, tokenIndex123 := position, tokenIndex
					if !_rules[ruleExponentPart]() {
						goto l123
					}
					goto l124
				l123:
					position, tokenIndex = position123, tokenIndex123
				}
			l124:
				add(ruleNumber, position118)
			}
			return true
		l117:
			position, tokenIndex = position117, tokenIndex117
			return false
		},
		/* 20 Minus <- <'-'> */
		func() bool {
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				if buffer[position] != rune('-') {
					goto l125
				}
				position++
				add(ruleMinus, position126)
			}
			return true
		l125:
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 21 IntegralPart <- <('0' / ([1-9] [0-9]*))> */
		func() bool {
			position127, tokenIndex127 := position, tokenIndex
			{
				position128 := position
				{
					position129, tokenIndex129 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l130
					}
					position++
					goto l129
				l130:
					position, tokenIndex = position129, tokenIndex129
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l127
					}
					position++
				l131:
					{
						position132, tokenIndex132 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l132
						}
						position++
						goto l131
					l132:
						position, tokenIndex = position132, tokenIndex132
					}
				}
			l129:
				add(ruleIntegralPart, position128)
			}
			return true
		l127:
			position, tokenIndex = position127, tokenIndex127
			return false
		},
		/* 22 FractionalPart <- <('.' [0-9]+)> */
		func() bool {
			position133, tokenIndex133 := position, tokenIndex
			{
				position134 := position
				if buffer[position] != rune('.') {
					goto l133
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l133
				}
				position++
			l135:
				{
					position136, tokenIndex136 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l136
					}
					position++
					goto l135
				l136:
					position, tokenIndex = position136, tokenIndex136
				}
				add(ruleFractionalPart, position134)
			}
			return true
		l133:
			position, tokenIndex = position133, tokenIndex133
			return false
		},
		/* 23 ExponentPart <- <(('e' / 'E') ('+' / '-')? [0-9]+)> */
		func() bool {
			position137, tokenIndex137 := position, tokenIndex
			{
				position138 := position
				{
					position139, tokenIndex139 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l140
					}
					position++
					goto l139
				l140:
					position, tokenIndex = position139, tokenIndex139
					if buffer[position] != rune('E') {
						goto l137
					}
					position++
				}
			l139:
				{
					position141, tokenIndex141 := position, tokenIndex
					{
						position143, tokenIndex143 := position, tokenIndex
						if buffer[position] != rune('+') {
							goto l144
						}
						position++
						goto l143
					l144:
						position, tokenIndex = position143, tokenIndex143
						if buffer[position] != rune('-') {
							goto l141
						}
						position++
					}
				l143:
					goto l142
				l141:
					position, tokenIndex = position141, tokenIndex141
				}
			l142:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l137
				}
				position++
			l145:
				{
					position146, tokenIndex146 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l146
					}
					position++
					goto l145
				l146:
					position, tokenIndex = position146, tokenIndex146
				}
				add(ruleExponentPart, position138)
			}
			return true
		l137:
			position, tokenIndex = position137, tokenIndex137
			return false
		},
		/* 24 Spacing <- <(Whitespace / LongComment / LineComment / Pragma)*> */
		func() bool {
			{
				position148 := position
			l149:
				{
					position150, tokenIndex150 := position, tokenIndex
					{
						position151, tokenIndex151 := position, tokenIndex
						if !_rules[ruleWhitespace]() {
							goto l152
						}
						goto l151
					l152:
						position, tokenIndex = position151, tokenIndex151
						if !_rules[ruleLongComment]() {
							goto l153
						}
						goto l151
					l153:
						position, tokenIndex = position151, tokenIndex151
						if !_rules[ruleLineComment]() {
							goto l154
						}
						goto l151
					l154:
						position, tokenIndex = position151, tokenIndex151
						if !_rules[rulePragma]() {
							goto l150
						}
					}
				l151:
					goto l149
				l150:
					position, tokenIndex = position150, tokenIndex150
				}
				add(ruleSpacing, position148)
			}
			return true
		},
		/* 25 Whitespace <- <(' ' / '\t' / '\r' / '\n')+> */
		func() bool {
			position155, tokenIndex155 := position, tokenIndex
			{
				position156 := position
				{
					position159, tokenIndex159 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l160
					}
					position++
					goto l159
				l160:
					position, tokenIndex = position159, tokenIndex159
					if buffer[position] != rune('\t') {
						goto l161
					}
					position++
					goto l159
				l161:
					position, tokenIndex = position159, tokenIndex159
					if buffer[position] != rune('\r') {
						goto l162
					}
					position++
					goto l159
				l162:
					position, tokenIndex = position159, tokenIndex159
					if buffer[position] != rune('\n') {
						goto l155
					}
					position++
				}
			l159:
			l157:
				{
					position158, tokenIndex158 := position, tokenIndex
					{
						position163, tokenIndex163 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l164
						}
						position++
						goto l163
					l164:
						position, tokenIndex = position163, tokenIndex163
						if buffer[position] != rune('\t') {
							goto l165
						}
						position++
						goto l163
					l165:
						position, tokenIndex = position163, tokenIndex163
						if buffer[position] != rune('\r') {
							goto l166
						}
						position++
						goto l163
					l166:
						position, tokenIndex = position163, tokenIndex163
						if buffer[position] != rune('\n') {
							goto l158
						}
						position++
					}
				l163:
					goto l157
				l158:
					position, tokenIndex = position158, tokenIndex158
				}
				add(ruleWhitespace, position156)
			}
			return true
		l155:
			position, tokenIndex = position155, tokenIndex155
			return false
		},
		/* 26 LongComment <- <('/' '*' (!('*' '/') .)* ('*' '/'))> */
		func() bool {
			position167, tokenIndex167 := position, tokenIndex
			{
				position168 := position
				if buffer[position] != rune('/') {
					goto l167
				}
				position++
				if buffer[position] != rune('*') {
					goto l167
				}
				position++
			l169:
				{
					position170, tokenIndex170 := position, tokenIndex
					{
						position171, tokenIndex171 := position, tokenIndex
						if buffer[position] != rune('*') {
							goto l171
						}
						position++
						if buffer[position] != rune('/') {
							goto l171
						}
						position++
						goto l170
					l171:
						position, tokenIndex = position171, tokenIndex171
					}
					if !matchDot() {
						goto l170
					}
					goto l169
				l170:
					position, tokenIndex = position170, tokenIndex170
				}
				if buffer[position] != rune('*') {
					goto l167
				}
				position++
				if buffer[position] != rune('/') {
					goto l167
				}
				position++
				add(ruleLongComment, position168)
			}
			return true
		l167:
			position, tokenIndex = position167, tokenIndex167
			return false
		},
		/* 27 LineComment <- <('/' '/' (!('\r' / '\n') .)* ('\r' / '\n'))> */
		func() bool {
			position172, tokenIndex172 := position, tokenIndex
			{
				position173 := position
				if buffer[position] != rune('/') {
					goto l172
				}
				position++
				if buffer[position] != rune('/') {
					goto l172
				}
				position++
			l174:
				{
					position175, tokenIndex175 := position, tokenIndex
					{
						position176, tokenIndex176 := position, tokenIndex
						{
							position177, tokenIndex177 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l178
							}
							position++
							goto l177
						l178:
							position, tokenIndex = position177, tokenIndex177
							if buffer[position] != rune('\n') {
								goto l176
							}
							position++
						}
					l177:
						goto l175
					l176:
						position, tokenIndex = position176, tokenIndex176
					}
					if !matchDot() {
						goto l175
					}
					goto l174
				l175:
					position, tokenIndex = position175, tokenIndex175
				}
				{
					position179, tokenIndex179 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l180
					}
					position++
					goto l179
				l180:
					position, tokenIndex = position179, tokenIndex179
					if buffer[position] != rune('\n') {
						goto l172
					}
					position++
				}
			l179:
				add(ruleLineComment, position173)
			}
			return true
		l172:
			position, tokenIndex = position172, tokenIndex172
			return false
		},
		/* 28 Pragma <- <('#' (!('\r' / '\n') .)* ('\r' / '\n'))> */
		func() bool {
			position181, tokenIndex181 := position, tokenIndex
			{
				position182 := position
				if buffer[position] != rune('#') {
					goto l181
				}
				position++
			l183:
				{
					position184, tokenIndex184 := position, tokenIndex
					{
						position185, tokenIndex185 := position, tokenIndex
						{
							position186, tokenIndex186 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l187
							}
							position++
							goto l186
						l187:
							position, tokenIndex = position186, tokenIndex186
							if buffer[position] != rune('\n') {
								goto l185
							}
							position++
						}
					l186:
						goto l184
					l185:
						position, tokenIndex = position185, tokenIndex185
					}
					if !matchDot() {
						goto l184
					}
					goto l183
				l184:
					position, tokenIndex = position184, tokenIndex184
				}
				{
					position188, tokenIndex188 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l189
					}
					position++
					goto l188
				l189:
					position, tokenIndex = position188, tokenIndex188
					if buffer[position] != rune('\n') {
						goto l181
					}
					position++
				}
			l188:
				add(rulePragma, position182)
			}
			return true
		l181:
			position, tokenIndex = position181, tokenIndex181
			return false
		},
		/* 29 LWING <- <('{' Spacing)> */
		func() bool {
			position190, tokenIndex190 := position, tokenIndex
			{
				position191 := position
				if buffer[position] != rune('{') {
					goto l190
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l190
				}
				add(ruleLWING, position191)
			}
			return true
		l190:
			position, tokenIndex = position190, tokenIndex190
			return false
		},
		/* 30 RWING <- <('}' Spacing)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				if buffer[position] != rune('}') {
					goto l192
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l192
				}
				add(ruleRWING, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 31 LBRK <- <('[' Spacing)> */
		func() bool {
			position194, tokenIndex194 := position, tokenIndex
			{
				position195 := position
				if buffer[position] != rune('[') {
					goto l194
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l194
				}
				add(ruleLBRK, position195)
			}
			return true
		l194:
			position, tokenIndex = position194, tokenIndex194
			return false
		},
		/* 32 RBRK <- <(']' Spacing)> */
		func() bool {
			position196, tokenIndex196 := position, tokenIndex
			{
				position197 := position
				if buffer[position] != rune(']') {
					goto l196
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l196
				}
				add(ruleRBRK, position197)
			}
			return true
		l196:
			position, tokenIndex = position196, tokenIndex196
			return false
		},
		/* 33 COMMA <- <(',' Spacing)> */
		func() bool {
			position198, tokenIndex198 := position, tokenIndex
			{
				position199 := position
				if buffer[position] != rune(',') {
					goto l198
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l198
				}
				add(ruleCOMMA, position199)
			}
			return true
		l198:
			position, tokenIndex = position198, tokenIndex198
			return false
		},
		/* 34 COLON <- <(':' Spacing)> */
		func() bool {
			position200, tokenIndex200 := position, tokenIndex
			{
				position201 := position
				if buffer[position] != rune(':') {
					goto l200
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l200
				}
				add(ruleCOLON, position201)
			}
			return true
		l200:
			position, tokenIndex = position200, tokenIndex200
			return false
		},
		/* 35 EOT <- <!.> */
		func() bool {
			position202, tokenIndex202 := position, tokenIndex
			{
				position203 := position
				{
					position204, tokenIndex204 := position, tokenIndex
					if !matchDot() {
						goto l204
					}
					goto l202
				l204:
					position, tokenIndex = position204, tokenIndex204
				}
				add(ruleEOT, position203)
			}
			return true
		l202:
			position, tokenIndex = position202, tokenIndex202
			return false
		},
	}
	p.rules = _rules
	return nil
}
