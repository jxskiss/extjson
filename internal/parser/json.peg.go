package parser

// Code generated by peg -output ./parser/json.peg.go json.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleDocument
	ruleJSON
	ruleObject
	ruleObjectKey
	ruleArray
	ruleDirective
	ruleEnv
	ruleInclude
	ruleRefer
	ruleSimpleIdentifier
	ruleString
	ruleSingleQuoteLiteral
	ruleDoubleQuoteLiteral
	ruleSingleQuoteEscape
	ruleDoubleQuoteEscape
	ruleUnicodeEscape
	ruleHexDigit
	ruleTrue
	ruleFalse
	ruleNull
	ruleNumber
	ruleMinus
	ruleIntegralPart
	ruleFractionalPart
	ruleExponentPart
	ruleSpacing
	ruleWhitespace
	ruleLongComment
	ruleLineComment
	rulePragma
	ruleLWING
	ruleRWING
	ruleLBRK
	ruleRBRK
	ruleCOMMA
	ruleCOLON
	ruleEOT
)

var rul3s = [...]string{
	"Unknown",
	"Document",
	"JSON",
	"Object",
	"ObjectKey",
	"Array",
	"Directive",
	"Env",
	"Include",
	"Refer",
	"SimpleIdentifier",
	"String",
	"SingleQuoteLiteral",
	"DoubleQuoteLiteral",
	"SingleQuoteEscape",
	"DoubleQuoteEscape",
	"UnicodeEscape",
	"HexDigit",
	"True",
	"False",
	"Null",
	"Number",
	"Minus",
	"IntegralPart",
	"FractionalPart",
	"ExponentPart",
	"Spacing",
	"Whitespace",
	"LongComment",
	"LineComment",
	"Pragma",
	"LWING",
	"RWING",
	"LBRK",
	"RBRK",
	"COMMA",
	"COLON",
	"EOT",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type JSON struct {
	Buffer string
	buffer []rune
	rules  [38]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *JSON) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *JSON) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *JSON
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *JSON) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *JSON) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *JSON) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*JSON) error {
	return func(p *JSON) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*JSON) error {
	return func(p *JSON) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *JSON) Init(options ...func(*JSON) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Document <- <(Spacing JSON EOT)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpacing]() {
					goto l0
				}
				if !_rules[ruleJSON]() {
					goto l0
				}
				if !_rules[ruleEOT]() {
					goto l0
				}
				add(ruleDocument, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 JSON <- <((Object / Array / String / True / False / Null / Number / Directive) Spacing)> */
		func() bool {
			position2, tokenIndex2 := position, tokenIndex
			{
				position3 := position
				{
					position4, tokenIndex4 := position, tokenIndex
					if !_rules[ruleObject]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleArray]() {
						goto l6
					}
					goto l4
				l6:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleString]() {
						goto l7
					}
					goto l4
				l7:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleTrue]() {
						goto l8
					}
					goto l4
				l8:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleFalse]() {
						goto l9
					}
					goto l4
				l9:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleNull]() {
						goto l10
					}
					goto l4
				l10:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleNumber]() {
						goto l11
					}
					goto l4
				l11:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDirective]() {
						goto l2
					}
				}
			l4:
				if !_rules[ruleSpacing]() {
					goto l2
				}
				add(ruleJSON, position3)
			}
			return true
		l2:
			position, tokenIndex = position2, tokenIndex2
			return false
		},
		/* 2 Object <- <(LWING (ObjectKey COLON JSON COMMA)* (ObjectKey COLON JSON)? RWING)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[ruleLWING]() {
					goto l12
				}
			l14:
				{
					position15, tokenIndex15 := position, tokenIndex
					if !_rules[ruleObjectKey]() {
						goto l15
					}
					if !_rules[ruleCOLON]() {
						goto l15
					}
					if !_rules[ruleJSON]() {
						goto l15
					}
					if !_rules[ruleCOMMA]() {
						goto l15
					}
					goto l14
				l15:
					position, tokenIndex = position15, tokenIndex15
				}
				{
					position16, tokenIndex16 := position, tokenIndex
					if !_rules[ruleObjectKey]() {
						goto l16
					}
					if !_rules[ruleCOLON]() {
						goto l16
					}
					if !_rules[ruleJSON]() {
						goto l16
					}
					goto l17
				l16:
					position, tokenIndex = position16, tokenIndex16
				}
			l17:
				if !_rules[ruleRWING]() {
					goto l12
				}
				add(ruleObject, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 ObjectKey <- <(String / SimpleIdentifier)> */
		func() bool {
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				{
					position20, tokenIndex20 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position20, tokenIndex20
					if !_rules[ruleSimpleIdentifier]() {
						goto l18
					}
				}
			l20:
				add(ruleObjectKey, position19)
			}
			return true
		l18:
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 4 Array <- <(LBRK (JSON COMMA)* JSON? RBRK)> */
		func() bool {
			position22, tokenIndex22 := position, tokenIndex
			{
				position23 := position
				if !_rules[ruleLBRK]() {
					goto l22
				}
			l24:
				{
					position25, tokenIndex25 := position, tokenIndex
					if !_rules[ruleJSON]() {
						goto l25
					}
					if !_rules[ruleCOMMA]() {
						goto l25
					}
					goto l24
				l25:
					position, tokenIndex = position25, tokenIndex25
				}
				{
					position26, tokenIndex26 := position, tokenIndex
					if !_rules[ruleJSON]() {
						goto l26
					}
					goto l27
				l26:
					position, tokenIndex = position26, tokenIndex26
				}
			l27:
				if !_rules[ruleRBRK]() {
					goto l22
				}
				add(ruleArray, position23)
			}
			return true
		l22:
			position, tokenIndex = position22, tokenIndex22
			return false
		},
		/* 5 Directive <- <(Env / Include / Refer)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				{
					position30, tokenIndex30 := position, tokenIndex
					if !_rules[ruleEnv]() {
						goto l31
					}
					goto l30
				l31:
					position, tokenIndex = position30, tokenIndex30
					if !_rules[ruleInclude]() {
						goto l32
					}
					goto l30
				l32:
					position, tokenIndex = position30, tokenIndex30
					if !_rules[ruleRefer]() {
						goto l28
					}
				}
			l30:
				add(ruleDirective, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 6 Env <- <('@' 'e' 'n' 'v' '(' String ')')> */
		func() bool {
			position33, tokenIndex33 := position, tokenIndex
			{
				position34 := position
				if buffer[position] != rune('@') {
					goto l33
				}
				position++
				if buffer[position] != rune('e') {
					goto l33
				}
				position++
				if buffer[position] != rune('n') {
					goto l33
				}
				position++
				if buffer[position] != rune('v') {
					goto l33
				}
				position++
				if buffer[position] != rune('(') {
					goto l33
				}
				position++
				if !_rules[ruleString]() {
					goto l33
				}
				if buffer[position] != rune(')') {
					goto l33
				}
				position++
				add(ruleEnv, position34)
			}
			return true
		l33:
			position, tokenIndex = position33, tokenIndex33
			return false
		},
		/* 7 Include <- <('@' 'i' 'n' 'c' 'l' '(' String ')')> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				if buffer[position] != rune('@') {
					goto l35
				}
				position++
				if buffer[position] != rune('i') {
					goto l35
				}
				position++
				if buffer[position] != rune('n') {
					goto l35
				}
				position++
				if buffer[position] != rune('c') {
					goto l35
				}
				position++
				if buffer[position] != rune('l') {
					goto l35
				}
				position++
				if buffer[position] != rune('(') {
					goto l35
				}
				position++
				if !_rules[ruleString]() {
					goto l35
				}
				if buffer[position] != rune(')') {
					goto l35
				}
				position++
				add(ruleInclude, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 8 Refer <- <('@' 'r' 'e' 'f' '(' String ')')> */
		func() bool {
			position37, tokenIndex37 := position, tokenIndex
			{
				position38 := position
				if buffer[position] != rune('@') {
					goto l37
				}
				position++
				if buffer[position] != rune('r') {
					goto l37
				}
				position++
				if buffer[position] != rune('e') {
					goto l37
				}
				position++
				if buffer[position] != rune('f') {
					goto l37
				}
				position++
				if buffer[position] != rune('(') {
					goto l37
				}
				position++
				if !_rules[ruleString]() {
					goto l37
				}
				if buffer[position] != rune(')') {
					goto l37
				}
				position++
				add(ruleRefer, position38)
			}
			return true
		l37:
			position, tokenIndex = position37, tokenIndex37
			return false
		},
		/* 9 SimpleIdentifier <- <([0-9] / [A-Z] / [a-z] / '_' / '$')+> */
		func() bool {
			position39, tokenIndex39 := position, tokenIndex
			{
				position40 := position
				{
					position43, tokenIndex43 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l44
					}
					position++
					goto l43
				l44:
					position, tokenIndex = position43, tokenIndex43
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l45
					}
					position++
					goto l43
				l45:
					position, tokenIndex = position43, tokenIndex43
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l46
					}
					position++
					goto l43
				l46:
					position, tokenIndex = position43, tokenIndex43
					if buffer[position] != rune('_') {
						goto l47
					}
					position++
					goto l43
				l47:
					position, tokenIndex = position43, tokenIndex43
					if buffer[position] != rune('$') {
						goto l39
					}
					position++
				}
			l43:
			l41:
				{
					position42, tokenIndex42 := position, tokenIndex
					{
						position48, tokenIndex48 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l49
						}
						position++
						goto l48
					l49:
						position, tokenIndex = position48, tokenIndex48
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l50
						}
						position++
						goto l48
					l50:
						position, tokenIndex = position48, tokenIndex48
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l51
						}
						position++
						goto l48
					l51:
						position, tokenIndex = position48, tokenIndex48
						if buffer[position] != rune('_') {
							goto l52
						}
						position++
						goto l48
					l52:
						position, tokenIndex = position48, tokenIndex48
						if buffer[position] != rune('$') {
							goto l42
						}
						position++
					}
				l48:
					goto l41
				l42:
					position, tokenIndex = position42, tokenIndex42
				}
				add(ruleSimpleIdentifier, position40)
			}
			return true
		l39:
			position, tokenIndex = position39, tokenIndex39
			return false
		},
		/* 10 String <- <(SingleQuoteLiteral / DoubleQuoteLiteral)> */
		func() bool {
			position53, tokenIndex53 := position, tokenIndex
			{
				position54 := position
				{
					position55, tokenIndex55 := position, tokenIndex
					if !_rules[ruleSingleQuoteLiteral]() {
						goto l56
					}
					goto l55
				l56:
					position, tokenIndex = position55, tokenIndex55
					if !_rules[ruleDoubleQuoteLiteral]() {
						goto l53
					}
				}
			l55:
				add(ruleString, position54)
			}
			return true
		l53:
			position, tokenIndex = position53, tokenIndex53
			return false
		},
		/* 11 SingleQuoteLiteral <- <('\'' (SingleQuoteEscape / (!('\'' / '\\' / '\n' / '\r') .))* '\'')> */
		func() bool {
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				if buffer[position] != rune('\'') {
					goto l57
				}
				position++
			l59:
				{
					position60, tokenIndex60 := position, tokenIndex
					{
						position61, tokenIndex61 := position, tokenIndex
						if !_rules[ruleSingleQuoteEscape]() {
							goto l62
						}
						goto l61
					l62:
						position, tokenIndex = position61, tokenIndex61
						{
							position63, tokenIndex63 := position, tokenIndex
							{
								position64, tokenIndex64 := position, tokenIndex
								if buffer[position] != rune('\'') {
									goto l65
								}
								position++
								goto l64
							l65:
								position, tokenIndex = position64, tokenIndex64
								if buffer[position] != rune('\\') {
									goto l66
								}
								position++
								goto l64
							l66:
								position, tokenIndex = position64, tokenIndex64
								if buffer[position] != rune('\n') {
									goto l67
								}
								position++
								goto l64
							l67:
								position, tokenIndex = position64, tokenIndex64
								if buffer[position] != rune('\r') {
									goto l63
								}
								position++
							}
						l64:
							goto l60
						l63:
							position, tokenIndex = position63, tokenIndex63
						}
						if !matchDot() {
							goto l60
						}
					}
				l61:
					goto l59
				l60:
					position, tokenIndex = position60, tokenIndex60
				}
				if buffer[position] != rune('\'') {
					goto l57
				}
				position++
				add(ruleSingleQuoteLiteral, position58)
			}
			return true
		l57:
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 12 DoubleQuoteLiteral <- <('"' (DoubleQuoteEscape / (!('"' / '\\' / '\n' / '\r') .))* '"')> */
		func() bool {
			position68, tokenIndex68 := position, tokenIndex
			{
				position69 := position
				if buffer[position] != rune('"') {
					goto l68
				}
				position++
			l70:
				{
					position71, tokenIndex71 := position, tokenIndex
					{
						position72, tokenIndex72 := position, tokenIndex
						if !_rules[ruleDoubleQuoteEscape]() {
							goto l73
						}
						goto l72
					l73:
						position, tokenIndex = position72, tokenIndex72
						{
							position74, tokenIndex74 := position, tokenIndex
							{
								position75, tokenIndex75 := position, tokenIndex
								if buffer[position] != rune('"') {
									goto l76
								}
								position++
								goto l75
							l76:
								position, tokenIndex = position75, tokenIndex75
								if buffer[position] != rune('\\') {
									goto l77
								}
								position++
								goto l75
							l77:
								position, tokenIndex = position75, tokenIndex75
								if buffer[position] != rune('\n') {
									goto l78
								}
								position++
								goto l75
							l78:
								position, tokenIndex = position75, tokenIndex75
								if buffer[position] != rune('\r') {
									goto l74
								}
								position++
							}
						l75:
							goto l71
						l74:
							position, tokenIndex = position74, tokenIndex74
						}
						if !matchDot() {
							goto l71
						}
					}
				l72:
					goto l70
				l71:
					position, tokenIndex = position71, tokenIndex71
				}
				if buffer[position] != rune('"') {
					goto l68
				}
				position++
				add(ruleDoubleQuoteLiteral, position69)
			}
			return true
		l68:
			position, tokenIndex = position68, tokenIndex68
			return false
		},
		/* 13 SingleQuoteEscape <- <('\\' ('b' / 't' / 'n' / 'f' / 'r' / '\'' / '\\' / '/' / UnicodeEscape))> */
		func() bool {
			position79, tokenIndex79 := position, tokenIndex
			{
				position80 := position
				if buffer[position] != rune('\\') {
					goto l79
				}
				position++
				{
					position81, tokenIndex81 := position, tokenIndex
					if buffer[position] != rune('b') {
						goto l82
					}
					position++
					goto l81
				l82:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('t') {
						goto l83
					}
					position++
					goto l81
				l83:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('n') {
						goto l84
					}
					position++
					goto l81
				l84:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('f') {
						goto l85
					}
					position++
					goto l81
				l85:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('r') {
						goto l86
					}
					position++
					goto l81
				l86:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('\'') {
						goto l87
					}
					position++
					goto l81
				l87:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('\\') {
						goto l88
					}
					position++
					goto l81
				l88:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('/') {
						goto l89
					}
					position++
					goto l81
				l89:
					position, tokenIndex = position81, tokenIndex81
					if !_rules[ruleUnicodeEscape]() {
						goto l79
					}
				}
			l81:
				add(ruleSingleQuoteEscape, position80)
			}
			return true
		l79:
			position, tokenIndex = position79, tokenIndex79
			return false
		},
		/* 14 DoubleQuoteEscape <- <('\\' ('b' / 't' / 'n' / 'f' / 'r' / '"' / '\\' / '/' / UnicodeEscape))> */
		func() bool {
			position90, tokenIndex90 := position, tokenIndex
			{
				position91 := position
				if buffer[position] != rune('\\') {
					goto l90
				}
				position++
				{
					position92, tokenIndex92 := position, tokenIndex
					if buffer[position] != rune('b') {
						goto l93
					}
					position++
					goto l92
				l93:
					position, tokenIndex = position92, tokenIndex92
					if buffer[position] != rune('t') {
						goto l94
					}
					position++
					goto l92
				l94:
					position, tokenIndex = position92, tokenIndex92
					if buffer[position] != rune('n') {
						goto l95
					}
					position++
					goto l92
				l95:
					position, tokenIndex = position92, tokenIndex92
					if buffer[position] != rune('f') {
						goto l96
					}
					position++
					goto l92
				l96:
					position, tokenIndex = position92, tokenIndex92
					if buffer[position] != rune('r') {
						goto l97
					}
					position++
					goto l92
				l97:
					position, tokenIndex = position92, tokenIndex92
					if buffer[position] != rune('"') {
						goto l98
					}
					position++
					goto l92
				l98:
					position, tokenIndex = position92, tokenIndex92
					if buffer[position] != rune('\\') {
						goto l99
					}
					position++
					goto l92
				l99:
					position, tokenIndex = position92, tokenIndex92
					if buffer[position] != rune('/') {
						goto l100
					}
					position++
					goto l92
				l100:
					position, tokenIndex = position92, tokenIndex92
					if !_rules[ruleUnicodeEscape]() {
						goto l90
					}
				}
			l92:
				add(ruleDoubleQuoteEscape, position91)
			}
			return true
		l90:
			position, tokenIndex = position90, tokenIndex90
			return false
		},
		/* 15 UnicodeEscape <- <('u' HexDigit HexDigit HexDigit HexDigit)> */
		func() bool {
			position101, tokenIndex101 := position, tokenIndex
			{
				position102 := position
				if buffer[position] != rune('u') {
					goto l101
				}
				position++
				if !_rules[ruleHexDigit]() {
					goto l101
				}
				if !_rules[ruleHexDigit]() {
					goto l101
				}
				if !_rules[ruleHexDigit]() {
					goto l101
				}
				if !_rules[ruleHexDigit]() {
					goto l101
				}
				add(ruleUnicodeEscape, position102)
			}
			return true
		l101:
			position, tokenIndex = position101, tokenIndex101
			return false
		},
		/* 16 HexDigit <- <([a-f] / [A-F] / [0-9])> */
		func() bool {
			position103, tokenIndex103 := position, tokenIndex
			{
				position104 := position
				{
					position105, tokenIndex105 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('f') {
						goto l106
					}
					position++
					goto l105
				l106:
					position, tokenIndex = position105, tokenIndex105
					if c := buffer[position]; c < rune('A') || c > rune('F') {
						goto l107
					}
					position++
					goto l105
				l107:
					position, tokenIndex = position105, tokenIndex105
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l103
					}
					position++
				}
			l105:
				add(ruleHexDigit, position104)
			}
			return true
		l103:
			position, tokenIndex = position103, tokenIndex103
			return false
		},
		/* 17 True <- <(('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e'))> */
		func() bool {
			position108, tokenIndex108 := position, tokenIndex
			{
				position109 := position
				{
					position110, tokenIndex110 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l111
					}
					position++
					if buffer[position] != rune('r') {
						goto l111
					}
					position++
					if buffer[position] != rune('u') {
						goto l111
					}
					position++
					if buffer[position] != rune('e') {
						goto l111
					}
					position++
					goto l110
				l111:
					position, tokenIndex = position110, tokenIndex110
					if buffer[position] != rune('T') {
						goto l108
					}
					position++
					if buffer[position] != rune('r') {
						goto l108
					}
					position++
					if buffer[position] != rune('u') {
						goto l108
					}
					position++
					if buffer[position] != rune('e') {
						goto l108
					}
					position++
				}
			l110:
				add(ruleTrue, position109)
			}
			return true
		l108:
			position, tokenIndex = position108, tokenIndex108
			return false
		},
		/* 18 False <- <(('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e'))> */
		func() bool {
			position112, tokenIndex112 := position, tokenIndex
			{
				position113 := position
				{
					position114, tokenIndex114 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l115
					}
					position++
					if buffer[position] != rune('a') {
						goto l115
					}
					position++
					if buffer[position] != rune('l') {
						goto l115
					}
					position++
					if buffer[position] != rune('s') {
						goto l115
					}
					position++
					if buffer[position] != rune('e') {
						goto l115
					}
					position++
					goto l114
				l115:
					position, tokenIndex = position114, tokenIndex114
					if buffer[position] != rune('F') {
						goto l112
					}
					position++
					if buffer[position] != rune('a') {
						goto l112
					}
					position++
					if buffer[position] != rune('l') {
						goto l112
					}
					position++
					if buffer[position] != rune('s') {
						goto l112
					}
					position++
					if buffer[position] != rune('e') {
						goto l112
					}
					position++
				}
			l114:
				add(ruleFalse, position113)
			}
			return true
		l112:
			position, tokenIndex = position112, tokenIndex112
			return false
		},
		/* 19 Null <- <(('n' 'u' 'l' 'l') / ('N' 'o' 'n' 'e'))> */
		func() bool {
			position116, tokenIndex116 := position, tokenIndex
			{
				position117 := position
				{
					position118, tokenIndex118 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l119
					}
					position++
					if buffer[position] != rune('u') {
						goto l119
					}
					position++
					if buffer[position] != rune('l') {
						goto l119
					}
					position++
					if buffer[position] != rune('l') {
						goto l119
					}
					position++
					goto l118
				l119:
					position, tokenIndex = position118, tokenIndex118
					if buffer[position] != rune('N') {
						goto l116
					}
					position++
					if buffer[position] != rune('o') {
						goto l116
					}
					position++
					if buffer[position] != rune('n') {
						goto l116
					}
					position++
					if buffer[position] != rune('e') {
						goto l116
					}
					position++
				}
			l118:
				add(ruleNull, position117)
			}
			return true
		l116:
			position, tokenIndex = position116, tokenIndex116
			return false
		},
		/* 20 Number <- <(Minus? IntegralPart FractionalPart? ExponentPart?)> */
		func() bool {
			position120, tokenIndex120 := position, tokenIndex
			{
				position121 := position
				{
					position122, tokenIndex122 := position, tokenIndex
					if !_rules[ruleMinus]() {
						goto l122
					}
					goto l123
				l122:
					position, tokenIndex = position122, tokenIndex122
				}
			l123:
				if !_rules[ruleIntegralPart]() {
					goto l120
				}
				{
					position124, tokenIndex124 := position, tokenIndex
					if !_rules[ruleFractionalPart]() {
						goto l124
					}
					goto l125
				l124:
					position, tokenIndex = position124, tokenIndex124
				}
			l125:
				{
					position126, tokenIndex126 := position, tokenIndex
					if !_rules[ruleExponentPart]() {
						goto l126
					}
					goto l127
				l126:
					position, tokenIndex = position126, tokenIndex126
				}
			l127:
				add(ruleNumber, position121)
			}
			return true
		l120:
			position, tokenIndex = position120, tokenIndex120
			return false
		},
		/* 21 Minus <- <'-'> */
		func() bool {
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				if buffer[position] != rune('-') {
					goto l128
				}
				position++
				add(ruleMinus, position129)
			}
			return true
		l128:
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 22 IntegralPart <- <('0' / ([1-9] [0-9]*))> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				{
					position132, tokenIndex132 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l133
					}
					position++
					goto l132
				l133:
					position, tokenIndex = position132, tokenIndex132
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l130
					}
					position++
				l134:
					{
						position135, tokenIndex135 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l135
						}
						position++
						goto l134
					l135:
						position, tokenIndex = position135, tokenIndex135
					}
				}
			l132:
				add(ruleIntegralPart, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 23 FractionalPart <- <('.' [0-9]+)> */
		func() bool {
			position136, tokenIndex136 := position, tokenIndex
			{
				position137 := position
				if buffer[position] != rune('.') {
					goto l136
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l136
				}
				position++
			l138:
				{
					position139, tokenIndex139 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l139
					}
					position++
					goto l138
				l139:
					position, tokenIndex = position139, tokenIndex139
				}
				add(ruleFractionalPart, position137)
			}
			return true
		l136:
			position, tokenIndex = position136, tokenIndex136
			return false
		},
		/* 24 ExponentPart <- <(('e' / 'E') ('+' / '-')? [0-9]+)> */
		func() bool {
			position140, tokenIndex140 := position, tokenIndex
			{
				position141 := position
				{
					position142, tokenIndex142 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l143
					}
					position++
					goto l142
				l143:
					position, tokenIndex = position142, tokenIndex142
					if buffer[position] != rune('E') {
						goto l140
					}
					position++
				}
			l142:
				{
					position144, tokenIndex144 := position, tokenIndex
					{
						position146, tokenIndex146 := position, tokenIndex
						if buffer[position] != rune('+') {
							goto l147
						}
						position++
						goto l146
					l147:
						position, tokenIndex = position146, tokenIndex146
						if buffer[position] != rune('-') {
							goto l144
						}
						position++
					}
				l146:
					goto l145
				l144:
					position, tokenIndex = position144, tokenIndex144
				}
			l145:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l140
				}
				position++
			l148:
				{
					position149, tokenIndex149 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l149
					}
					position++
					goto l148
				l149:
					position, tokenIndex = position149, tokenIndex149
				}
				add(ruleExponentPart, position141)
			}
			return true
		l140:
			position, tokenIndex = position140, tokenIndex140
			return false
		},
		/* 25 Spacing <- <(Whitespace / LongComment / LineComment / Pragma)*> */
		func() bool {
			{
				position151 := position
			l152:
				{
					position153, tokenIndex153 := position, tokenIndex
					{
						position154, tokenIndex154 := position, tokenIndex
						if !_rules[ruleWhitespace]() {
							goto l155
						}
						goto l154
					l155:
						position, tokenIndex = position154, tokenIndex154
						if !_rules[ruleLongComment]() {
							goto l156
						}
						goto l154
					l156:
						position, tokenIndex = position154, tokenIndex154
						if !_rules[ruleLineComment]() {
							goto l157
						}
						goto l154
					l157:
						position, tokenIndex = position154, tokenIndex154
						if !_rules[rulePragma]() {
							goto l153
						}
					}
				l154:
					goto l152
				l153:
					position, tokenIndex = position153, tokenIndex153
				}
				add(ruleSpacing, position151)
			}
			return true
		},
		/* 26 Whitespace <- <(' ' / '\t' / '\r' / '\n')+> */
		func() bool {
			position158, tokenIndex158 := position, tokenIndex
			{
				position159 := position
				{
					position162, tokenIndex162 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l163
					}
					position++
					goto l162
				l163:
					position, tokenIndex = position162, tokenIndex162
					if buffer[position] != rune('\t') {
						goto l164
					}
					position++
					goto l162
				l164:
					position, tokenIndex = position162, tokenIndex162
					if buffer[position] != rune('\r') {
						goto l165
					}
					position++
					goto l162
				l165:
					position, tokenIndex = position162, tokenIndex162
					if buffer[position] != rune('\n') {
						goto l158
					}
					position++
				}
			l162:
			l160:
				{
					position161, tokenIndex161 := position, tokenIndex
					{
						position166, tokenIndex166 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l167
						}
						position++
						goto l166
					l167:
						position, tokenIndex = position166, tokenIndex166
						if buffer[position] != rune('\t') {
							goto l168
						}
						position++
						goto l166
					l168:
						position, tokenIndex = position166, tokenIndex166
						if buffer[position] != rune('\r') {
							goto l169
						}
						position++
						goto l166
					l169:
						position, tokenIndex = position166, tokenIndex166
						if buffer[position] != rune('\n') {
							goto l161
						}
						position++
					}
				l166:
					goto l160
				l161:
					position, tokenIndex = position161, tokenIndex161
				}
				add(ruleWhitespace, position159)
			}
			return true
		l158:
			position, tokenIndex = position158, tokenIndex158
			return false
		},
		/* 27 LongComment <- <('/' '*' (!('*' '/') .)* ('*' '/'))> */
		func() bool {
			position170, tokenIndex170 := position, tokenIndex
			{
				position171 := position
				if buffer[position] != rune('/') {
					goto l170
				}
				position++
				if buffer[position] != rune('*') {
					goto l170
				}
				position++
			l172:
				{
					position173, tokenIndex173 := position, tokenIndex
					{
						position174, tokenIndex174 := position, tokenIndex
						if buffer[position] != rune('*') {
							goto l174
						}
						position++
						if buffer[position] != rune('/') {
							goto l174
						}
						position++
						goto l173
					l174:
						position, tokenIndex = position174, tokenIndex174
					}
					if !matchDot() {
						goto l173
					}
					goto l172
				l173:
					position, tokenIndex = position173, tokenIndex173
				}
				if buffer[position] != rune('*') {
					goto l170
				}
				position++
				if buffer[position] != rune('/') {
					goto l170
				}
				position++
				add(ruleLongComment, position171)
			}
			return true
		l170:
			position, tokenIndex = position170, tokenIndex170
			return false
		},
		/* 28 LineComment <- <('/' '/' (!('\r' / '\n') .)* ('\r' / '\n'))> */
		func() bool {
			position175, tokenIndex175 := position, tokenIndex
			{
				position176 := position
				if buffer[position] != rune('/') {
					goto l175
				}
				position++
				if buffer[position] != rune('/') {
					goto l175
				}
				position++
			l177:
				{
					position178, tokenIndex178 := position, tokenIndex
					{
						position179, tokenIndex179 := position, tokenIndex
						{
							position180, tokenIndex180 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l181
							}
							position++
							goto l180
						l181:
							position, tokenIndex = position180, tokenIndex180
							if buffer[position] != rune('\n') {
								goto l179
							}
							position++
						}
					l180:
						goto l178
					l179:
						position, tokenIndex = position179, tokenIndex179
					}
					if !matchDot() {
						goto l178
					}
					goto l177
				l178:
					position, tokenIndex = position178, tokenIndex178
				}
				{
					position182, tokenIndex182 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l183
					}
					position++
					goto l182
				l183:
					position, tokenIndex = position182, tokenIndex182
					if buffer[position] != rune('\n') {
						goto l175
					}
					position++
				}
			l182:
				add(ruleLineComment, position176)
			}
			return true
		l175:
			position, tokenIndex = position175, tokenIndex175
			return false
		},
		/* 29 Pragma <- <('#' (!('\r' / '\n') .)* ('\r' / '\n'))> */
		func() bool {
			position184, tokenIndex184 := position, tokenIndex
			{
				position185 := position
				if buffer[position] != rune('#') {
					goto l184
				}
				position++
			l186:
				{
					position187, tokenIndex187 := position, tokenIndex
					{
						position188, tokenIndex188 := position, tokenIndex
						{
							position189, tokenIndex189 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l190
							}
							position++
							goto l189
						l190:
							position, tokenIndex = position189, tokenIndex189
							if buffer[position] != rune('\n') {
								goto l188
							}
							position++
						}
					l189:
						goto l187
					l188:
						position, tokenIndex = position188, tokenIndex188
					}
					if !matchDot() {
						goto l187
					}
					goto l186
				l187:
					position, tokenIndex = position187, tokenIndex187
				}
				{
					position191, tokenIndex191 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l192
					}
					position++
					goto l191
				l192:
					position, tokenIndex = position191, tokenIndex191
					if buffer[position] != rune('\n') {
						goto l184
					}
					position++
				}
			l191:
				add(rulePragma, position185)
			}
			return true
		l184:
			position, tokenIndex = position184, tokenIndex184
			return false
		},
		/* 30 LWING <- <('{' Spacing)> */
		func() bool {
			position193, tokenIndex193 := position, tokenIndex
			{
				position194 := position
				if buffer[position] != rune('{') {
					goto l193
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l193
				}
				add(ruleLWING, position194)
			}
			return true
		l193:
			position, tokenIndex = position193, tokenIndex193
			return false
		},
		/* 31 RWING <- <('}' Spacing)> */
		func() bool {
			position195, tokenIndex195 := position, tokenIndex
			{
				position196 := position
				if buffer[position] != rune('}') {
					goto l195
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l195
				}
				add(ruleRWING, position196)
			}
			return true
		l195:
			position, tokenIndex = position195, tokenIndex195
			return false
		},
		/* 32 LBRK <- <('[' Spacing)> */
		func() bool {
			position197, tokenIndex197 := position, tokenIndex
			{
				position198 := position
				if buffer[position] != rune('[') {
					goto l197
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l197
				}
				add(ruleLBRK, position198)
			}
			return true
		l197:
			position, tokenIndex = position197, tokenIndex197
			return false
		},
		/* 33 RBRK <- <(']' Spacing)> */
		func() bool {
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				if buffer[position] != rune(']') {
					goto l199
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l199
				}
				add(ruleRBRK, position200)
			}
			return true
		l199:
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 34 COMMA <- <(',' Spacing)> */
		func() bool {
			position201, tokenIndex201 := position, tokenIndex
			{
				position202 := position
				if buffer[position] != rune(',') {
					goto l201
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l201
				}
				add(ruleCOMMA, position202)
			}
			return true
		l201:
			position, tokenIndex = position201, tokenIndex201
			return false
		},
		/* 35 COLON <- <(':' Spacing)> */
		func() bool {
			position203, tokenIndex203 := position, tokenIndex
			{
				position204 := position
				if buffer[position] != rune(':') {
					goto l203
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l203
				}
				add(ruleCOLON, position204)
			}
			return true
		l203:
			position, tokenIndex = position203, tokenIndex203
			return false
		},
		/* 36 EOT <- <!.> */
		func() bool {
			position205, tokenIndex205 := position, tokenIndex
			{
				position206 := position
				{
					position207, tokenIndex207 := position, tokenIndex
					if !matchDot() {
						goto l207
					}
					goto l205
				l207:
					position, tokenIndex = position207, tokenIndex207
				}
				add(ruleEOT, position206)
			}
			return true
		l205:
			position, tokenIndex = position205, tokenIndex205
			return false
		},
	}
	p.rules = _rules
	return nil
}
