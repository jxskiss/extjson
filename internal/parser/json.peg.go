package parser

// Code generated by peg -output ./internal/parser/json.peg.go json.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleDocument
	ruleJSON
	ruleObject
	ruleObjectKey
	ruleArray
	ruleDirective
	ruleEnv
	ruleInclude
	ruleRefer
	ruleFunc
	ruleSimpleIdentifier
	ruleString
	ruleSingleQuoteLiteral
	ruleDoubleQuoteLiteral
	ruleSingleQuoteEscape
	ruleDoubleQuoteEscape
	ruleUnicodeEscape
	ruleHexDigit
	ruleTrue
	ruleFalse
	ruleNull
	ruleNumber
	ruleMinus
	ruleIntegralPart
	ruleFractionalPart
	ruleExponentPart
	ruleSpacing
	ruleWhitespace
	ruleLongComment
	ruleLineComment
	rulePragma
	ruleLWING
	ruleRWING
	ruleLBRK
	ruleRBRK
	ruleCOMMA
	ruleCOLON
	ruleEOT
)

var rul3s = [...]string{
	"Unknown",
	"Document",
	"JSON",
	"Object",
	"ObjectKey",
	"Array",
	"Directive",
	"Env",
	"Include",
	"Refer",
	"Func",
	"SimpleIdentifier",
	"String",
	"SingleQuoteLiteral",
	"DoubleQuoteLiteral",
	"SingleQuoteEscape",
	"DoubleQuoteEscape",
	"UnicodeEscape",
	"HexDigit",
	"True",
	"False",
	"Null",
	"Number",
	"Minus",
	"IntegralPart",
	"FractionalPart",
	"ExponentPart",
	"Spacing",
	"Whitespace",
	"LongComment",
	"LineComment",
	"Pragma",
	"LWING",
	"RWING",
	"LBRK",
	"RBRK",
	"COMMA",
	"COLON",
	"EOT",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type JSON struct {
	Buffer string
	buffer []rune
	rules  [39]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *JSON) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *JSON) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *JSON
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *JSON) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *JSON) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *JSON) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*JSON) error {
	return func(p *JSON) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*JSON) error {
	return func(p *JSON) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *JSON) Init(options ...func(*JSON) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Document <- <(Spacing JSON EOT)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpacing]() {
					goto l0
				}
				if !_rules[ruleJSON]() {
					goto l0
				}
				if !_rules[ruleEOT]() {
					goto l0
				}
				add(ruleDocument, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 JSON <- <((Object / Array / String / True / False / Null / Number / Directive) Spacing)> */
		func() bool {
			position2, tokenIndex2 := position, tokenIndex
			{
				position3 := position
				{
					position4, tokenIndex4 := position, tokenIndex
					if !_rules[ruleObject]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleArray]() {
						goto l6
					}
					goto l4
				l6:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleString]() {
						goto l7
					}
					goto l4
				l7:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleTrue]() {
						goto l8
					}
					goto l4
				l8:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleFalse]() {
						goto l9
					}
					goto l4
				l9:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleNull]() {
						goto l10
					}
					goto l4
				l10:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleNumber]() {
						goto l11
					}
					goto l4
				l11:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDirective]() {
						goto l2
					}
				}
			l4:
				if !_rules[ruleSpacing]() {
					goto l2
				}
				add(ruleJSON, position3)
			}
			return true
		l2:
			position, tokenIndex = position2, tokenIndex2
			return false
		},
		/* 2 Object <- <(LWING (ObjectKey COLON JSON COMMA)* (ObjectKey COLON JSON)? RWING)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[ruleLWING]() {
					goto l12
				}
			l14:
				{
					position15, tokenIndex15 := position, tokenIndex
					if !_rules[ruleObjectKey]() {
						goto l15
					}
					if !_rules[ruleCOLON]() {
						goto l15
					}
					if !_rules[ruleJSON]() {
						goto l15
					}
					if !_rules[ruleCOMMA]() {
						goto l15
					}
					goto l14
				l15:
					position, tokenIndex = position15, tokenIndex15
				}
				{
					position16, tokenIndex16 := position, tokenIndex
					if !_rules[ruleObjectKey]() {
						goto l16
					}
					if !_rules[ruleCOLON]() {
						goto l16
					}
					if !_rules[ruleJSON]() {
						goto l16
					}
					goto l17
				l16:
					position, tokenIndex = position16, tokenIndex16
				}
			l17:
				if !_rules[ruleRWING]() {
					goto l12
				}
				add(ruleObject, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 ObjectKey <- <(String / SimpleIdentifier)> */
		func() bool {
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				{
					position20, tokenIndex20 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position20, tokenIndex20
					if !_rules[ruleSimpleIdentifier]() {
						goto l18
					}
				}
			l20:
				add(ruleObjectKey, position19)
			}
			return true
		l18:
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 4 Array <- <(LBRK (JSON COMMA)* JSON? RBRK)> */
		func() bool {
			position22, tokenIndex22 := position, tokenIndex
			{
				position23 := position
				if !_rules[ruleLBRK]() {
					goto l22
				}
			l24:
				{
					position25, tokenIndex25 := position, tokenIndex
					if !_rules[ruleJSON]() {
						goto l25
					}
					if !_rules[ruleCOMMA]() {
						goto l25
					}
					goto l24
				l25:
					position, tokenIndex = position25, tokenIndex25
				}
				{
					position26, tokenIndex26 := position, tokenIndex
					if !_rules[ruleJSON]() {
						goto l26
					}
					goto l27
				l26:
					position, tokenIndex = position26, tokenIndex26
				}
			l27:
				if !_rules[ruleRBRK]() {
					goto l22
				}
				add(ruleArray, position23)
			}
			return true
		l22:
			position, tokenIndex = position22, tokenIndex22
			return false
		},
		/* 5 Directive <- <(Env / Include / Refer / Func)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				{
					position30, tokenIndex30 := position, tokenIndex
					if !_rules[ruleEnv]() {
						goto l31
					}
					goto l30
				l31:
					position, tokenIndex = position30, tokenIndex30
					if !_rules[ruleInclude]() {
						goto l32
					}
					goto l30
				l32:
					position, tokenIndex = position30, tokenIndex30
					if !_rules[ruleRefer]() {
						goto l33
					}
					goto l30
				l33:
					position, tokenIndex = position30, tokenIndex30
					if !_rules[ruleFunc]() {
						goto l28
					}
				}
			l30:
				add(ruleDirective, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 6 Env <- <('@' 'e' 'n' 'v' '(' String ')')> */
		func() bool {
			position34, tokenIndex34 := position, tokenIndex
			{
				position35 := position
				if buffer[position] != rune('@') {
					goto l34
				}
				position++
				if buffer[position] != rune('e') {
					goto l34
				}
				position++
				if buffer[position] != rune('n') {
					goto l34
				}
				position++
				if buffer[position] != rune('v') {
					goto l34
				}
				position++
				if buffer[position] != rune('(') {
					goto l34
				}
				position++
				if !_rules[ruleString]() {
					goto l34
				}
				if buffer[position] != rune(')') {
					goto l34
				}
				position++
				add(ruleEnv, position35)
			}
			return true
		l34:
			position, tokenIndex = position34, tokenIndex34
			return false
		},
		/* 7 Include <- <('@' 'i' 'n' 'c' 'l' '(' String ')')> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
				if buffer[position] != rune('@') {
					goto l36
				}
				position++
				if buffer[position] != rune('i') {
					goto l36
				}
				position++
				if buffer[position] != rune('n') {
					goto l36
				}
				position++
				if buffer[position] != rune('c') {
					goto l36
				}
				position++
				if buffer[position] != rune('l') {
					goto l36
				}
				position++
				if buffer[position] != rune('(') {
					goto l36
				}
				position++
				if !_rules[ruleString]() {
					goto l36
				}
				if buffer[position] != rune(')') {
					goto l36
				}
				position++
				add(ruleInclude, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 8 Refer <- <('@' 'r' 'e' 'f' '(' String ')')> */
		func() bool {
			position38, tokenIndex38 := position, tokenIndex
			{
				position39 := position
				if buffer[position] != rune('@') {
					goto l38
				}
				position++
				if buffer[position] != rune('r') {
					goto l38
				}
				position++
				if buffer[position] != rune('e') {
					goto l38
				}
				position++
				if buffer[position] != rune('f') {
					goto l38
				}
				position++
				if buffer[position] != rune('(') {
					goto l38
				}
				position++
				if !_rules[ruleString]() {
					goto l38
				}
				if buffer[position] != rune(')') {
					goto l38
				}
				position++
				add(ruleRefer, position39)
			}
			return true
		l38:
			position, tokenIndex = position38, tokenIndex38
			return false
		},
		/* 9 Func <- <('@' 'f' 'n' '(' String ')')> */
		func() bool {
			position40, tokenIndex40 := position, tokenIndex
			{
				position41 := position
				if buffer[position] != rune('@') {
					goto l40
				}
				position++
				if buffer[position] != rune('f') {
					goto l40
				}
				position++
				if buffer[position] != rune('n') {
					goto l40
				}
				position++
				if buffer[position] != rune('(') {
					goto l40
				}
				position++
				if !_rules[ruleString]() {
					goto l40
				}
				if buffer[position] != rune(')') {
					goto l40
				}
				position++
				add(ruleFunc, position41)
			}
			return true
		l40:
			position, tokenIndex = position40, tokenIndex40
			return false
		},
		/* 10 SimpleIdentifier <- <([0-9] / [A-Z] / [a-z] / '_' / '$')+> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				{
					position46, tokenIndex46 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l47
					}
					position++
					goto l46
				l47:
					position, tokenIndex = position46, tokenIndex46
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l48
					}
					position++
					goto l46
				l48:
					position, tokenIndex = position46, tokenIndex46
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l49
					}
					position++
					goto l46
				l49:
					position, tokenIndex = position46, tokenIndex46
					if buffer[position] != rune('_') {
						goto l50
					}
					position++
					goto l46
				l50:
					position, tokenIndex = position46, tokenIndex46
					if buffer[position] != rune('$') {
						goto l42
					}
					position++
				}
			l46:
			l44:
				{
					position45, tokenIndex45 := position, tokenIndex
					{
						position51, tokenIndex51 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l52
						}
						position++
						goto l51
					l52:
						position, tokenIndex = position51, tokenIndex51
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l53
						}
						position++
						goto l51
					l53:
						position, tokenIndex = position51, tokenIndex51
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l54
						}
						position++
						goto l51
					l54:
						position, tokenIndex = position51, tokenIndex51
						if buffer[position] != rune('_') {
							goto l55
						}
						position++
						goto l51
					l55:
						position, tokenIndex = position51, tokenIndex51
						if buffer[position] != rune('$') {
							goto l45
						}
						position++
					}
				l51:
					goto l44
				l45:
					position, tokenIndex = position45, tokenIndex45
				}
				add(ruleSimpleIdentifier, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 11 String <- <(SingleQuoteLiteral / DoubleQuoteLiteral)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				{
					position58, tokenIndex58 := position, tokenIndex
					if !_rules[ruleSingleQuoteLiteral]() {
						goto l59
					}
					goto l58
				l59:
					position, tokenIndex = position58, tokenIndex58
					if !_rules[ruleDoubleQuoteLiteral]() {
						goto l56
					}
				}
			l58:
				add(ruleString, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 12 SingleQuoteLiteral <- <('\'' (SingleQuoteEscape / (!('\'' / '\\' / '\n' / '\r') .))* '\'')> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				if buffer[position] != rune('\'') {
					goto l60
				}
				position++
			l62:
				{
					position63, tokenIndex63 := position, tokenIndex
					{
						position64, tokenIndex64 := position, tokenIndex
						if !_rules[ruleSingleQuoteEscape]() {
							goto l65
						}
						goto l64
					l65:
						position, tokenIndex = position64, tokenIndex64
						{
							position66, tokenIndex66 := position, tokenIndex
							{
								position67, tokenIndex67 := position, tokenIndex
								if buffer[position] != rune('\'') {
									goto l68
								}
								position++
								goto l67
							l68:
								position, tokenIndex = position67, tokenIndex67
								if buffer[position] != rune('\\') {
									goto l69
								}
								position++
								goto l67
							l69:
								position, tokenIndex = position67, tokenIndex67
								if buffer[position] != rune('\n') {
									goto l70
								}
								position++
								goto l67
							l70:
								position, tokenIndex = position67, tokenIndex67
								if buffer[position] != rune('\r') {
									goto l66
								}
								position++
							}
						l67:
							goto l63
						l66:
							position, tokenIndex = position66, tokenIndex66
						}
						if !matchDot() {
							goto l63
						}
					}
				l64:
					goto l62
				l63:
					position, tokenIndex = position63, tokenIndex63
				}
				if buffer[position] != rune('\'') {
					goto l60
				}
				position++
				add(ruleSingleQuoteLiteral, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 13 DoubleQuoteLiteral <- <('"' (DoubleQuoteEscape / (!('"' / '\\' / '\n' / '\r') .))* '"')> */
		func() bool {
			position71, tokenIndex71 := position, tokenIndex
			{
				position72 := position
				if buffer[position] != rune('"') {
					goto l71
				}
				position++
			l73:
				{
					position74, tokenIndex74 := position, tokenIndex
					{
						position75, tokenIndex75 := position, tokenIndex
						if !_rules[ruleDoubleQuoteEscape]() {
							goto l76
						}
						goto l75
					l76:
						position, tokenIndex = position75, tokenIndex75
						{
							position77, tokenIndex77 := position, tokenIndex
							{
								position78, tokenIndex78 := position, tokenIndex
								if buffer[position] != rune('"') {
									goto l79
								}
								position++
								goto l78
							l79:
								position, tokenIndex = position78, tokenIndex78
								if buffer[position] != rune('\\') {
									goto l80
								}
								position++
								goto l78
							l80:
								position, tokenIndex = position78, tokenIndex78
								if buffer[position] != rune('\n') {
									goto l81
								}
								position++
								goto l78
							l81:
								position, tokenIndex = position78, tokenIndex78
								if buffer[position] != rune('\r') {
									goto l77
								}
								position++
							}
						l78:
							goto l74
						l77:
							position, tokenIndex = position77, tokenIndex77
						}
						if !matchDot() {
							goto l74
						}
					}
				l75:
					goto l73
				l74:
					position, tokenIndex = position74, tokenIndex74
				}
				if buffer[position] != rune('"') {
					goto l71
				}
				position++
				add(ruleDoubleQuoteLiteral, position72)
			}
			return true
		l71:
			position, tokenIndex = position71, tokenIndex71
			return false
		},
		/* 14 SingleQuoteEscape <- <('\\' ('b' / 't' / 'n' / 'f' / 'r' / '\'' / '\\' / '/' / UnicodeEscape))> */
		func() bool {
			position82, tokenIndex82 := position, tokenIndex
			{
				position83 := position
				if buffer[position] != rune('\\') {
					goto l82
				}
				position++
				{
					position84, tokenIndex84 := position, tokenIndex
					if buffer[position] != rune('b') {
						goto l85
					}
					position++
					goto l84
				l85:
					position, tokenIndex = position84, tokenIndex84
					if buffer[position] != rune('t') {
						goto l86
					}
					position++
					goto l84
				l86:
					position, tokenIndex = position84, tokenIndex84
					if buffer[position] != rune('n') {
						goto l87
					}
					position++
					goto l84
				l87:
					position, tokenIndex = position84, tokenIndex84
					if buffer[position] != rune('f') {
						goto l88
					}
					position++
					goto l84
				l88:
					position, tokenIndex = position84, tokenIndex84
					if buffer[position] != rune('r') {
						goto l89
					}
					position++
					goto l84
				l89:
					position, tokenIndex = position84, tokenIndex84
					if buffer[position] != rune('\'') {
						goto l90
					}
					position++
					goto l84
				l90:
					position, tokenIndex = position84, tokenIndex84
					if buffer[position] != rune('\\') {
						goto l91
					}
					position++
					goto l84
				l91:
					position, tokenIndex = position84, tokenIndex84
					if buffer[position] != rune('/') {
						goto l92
					}
					position++
					goto l84
				l92:
					position, tokenIndex = position84, tokenIndex84
					if !_rules[ruleUnicodeEscape]() {
						goto l82
					}
				}
			l84:
				add(ruleSingleQuoteEscape, position83)
			}
			return true
		l82:
			position, tokenIndex = position82, tokenIndex82
			return false
		},
		/* 15 DoubleQuoteEscape <- <('\\' ('b' / 't' / 'n' / 'f' / 'r' / '"' / '\\' / '/' / UnicodeEscape))> */
		func() bool {
			position93, tokenIndex93 := position, tokenIndex
			{
				position94 := position
				if buffer[position] != rune('\\') {
					goto l93
				}
				position++
				{
					position95, tokenIndex95 := position, tokenIndex
					if buffer[position] != rune('b') {
						goto l96
					}
					position++
					goto l95
				l96:
					position, tokenIndex = position95, tokenIndex95
					if buffer[position] != rune('t') {
						goto l97
					}
					position++
					goto l95
				l97:
					position, tokenIndex = position95, tokenIndex95
					if buffer[position] != rune('n') {
						goto l98
					}
					position++
					goto l95
				l98:
					position, tokenIndex = position95, tokenIndex95
					if buffer[position] != rune('f') {
						goto l99
					}
					position++
					goto l95
				l99:
					position, tokenIndex = position95, tokenIndex95
					if buffer[position] != rune('r') {
						goto l100
					}
					position++
					goto l95
				l100:
					position, tokenIndex = position95, tokenIndex95
					if buffer[position] != rune('"') {
						goto l101
					}
					position++
					goto l95
				l101:
					position, tokenIndex = position95, tokenIndex95
					if buffer[position] != rune('\\') {
						goto l102
					}
					position++
					goto l95
				l102:
					position, tokenIndex = position95, tokenIndex95
					if buffer[position] != rune('/') {
						goto l103
					}
					position++
					goto l95
				l103:
					position, tokenIndex = position95, tokenIndex95
					if !_rules[ruleUnicodeEscape]() {
						goto l93
					}
				}
			l95:
				add(ruleDoubleQuoteEscape, position94)
			}
			return true
		l93:
			position, tokenIndex = position93, tokenIndex93
			return false
		},
		/* 16 UnicodeEscape <- <('u' HexDigit HexDigit HexDigit HexDigit)> */
		func() bool {
			position104, tokenIndex104 := position, tokenIndex
			{
				position105 := position
				if buffer[position] != rune('u') {
					goto l104
				}
				position++
				if !_rules[ruleHexDigit]() {
					goto l104
				}
				if !_rules[ruleHexDigit]() {
					goto l104
				}
				if !_rules[ruleHexDigit]() {
					goto l104
				}
				if !_rules[ruleHexDigit]() {
					goto l104
				}
				add(ruleUnicodeEscape, position105)
			}
			return true
		l104:
			position, tokenIndex = position104, tokenIndex104
			return false
		},
		/* 17 HexDigit <- <([a-f] / [A-F] / [0-9])> */
		func() bool {
			position106, tokenIndex106 := position, tokenIndex
			{
				position107 := position
				{
					position108, tokenIndex108 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('f') {
						goto l109
					}
					position++
					goto l108
				l109:
					position, tokenIndex = position108, tokenIndex108
					if c := buffer[position]; c < rune('A') || c > rune('F') {
						goto l110
					}
					position++
					goto l108
				l110:
					position, tokenIndex = position108, tokenIndex108
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l106
					}
					position++
				}
			l108:
				add(ruleHexDigit, position107)
			}
			return true
		l106:
			position, tokenIndex = position106, tokenIndex106
			return false
		},
		/* 18 True <- <(('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e'))> */
		func() bool {
			position111, tokenIndex111 := position, tokenIndex
			{
				position112 := position
				{
					position113, tokenIndex113 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l114
					}
					position++
					if buffer[position] != rune('r') {
						goto l114
					}
					position++
					if buffer[position] != rune('u') {
						goto l114
					}
					position++
					if buffer[position] != rune('e') {
						goto l114
					}
					position++
					goto l113
				l114:
					position, tokenIndex = position113, tokenIndex113
					if buffer[position] != rune('T') {
						goto l111
					}
					position++
					if buffer[position] != rune('r') {
						goto l111
					}
					position++
					if buffer[position] != rune('u') {
						goto l111
					}
					position++
					if buffer[position] != rune('e') {
						goto l111
					}
					position++
				}
			l113:
				add(ruleTrue, position112)
			}
			return true
		l111:
			position, tokenIndex = position111, tokenIndex111
			return false
		},
		/* 19 False <- <(('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e'))> */
		func() bool {
			position115, tokenIndex115 := position, tokenIndex
			{
				position116 := position
				{
					position117, tokenIndex117 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l118
					}
					position++
					if buffer[position] != rune('a') {
						goto l118
					}
					position++
					if buffer[position] != rune('l') {
						goto l118
					}
					position++
					if buffer[position] != rune('s') {
						goto l118
					}
					position++
					if buffer[position] != rune('e') {
						goto l118
					}
					position++
					goto l117
				l118:
					position, tokenIndex = position117, tokenIndex117
					if buffer[position] != rune('F') {
						goto l115
					}
					position++
					if buffer[position] != rune('a') {
						goto l115
					}
					position++
					if buffer[position] != rune('l') {
						goto l115
					}
					position++
					if buffer[position] != rune('s') {
						goto l115
					}
					position++
					if buffer[position] != rune('e') {
						goto l115
					}
					position++
				}
			l117:
				add(ruleFalse, position116)
			}
			return true
		l115:
			position, tokenIndex = position115, tokenIndex115
			return false
		},
		/* 20 Null <- <(('n' 'u' 'l' 'l') / ('N' 'o' 'n' 'e'))> */
		func() bool {
			position119, tokenIndex119 := position, tokenIndex
			{
				position120 := position
				{
					position121, tokenIndex121 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l122
					}
					position++
					if buffer[position] != rune('u') {
						goto l122
					}
					position++
					if buffer[position] != rune('l') {
						goto l122
					}
					position++
					if buffer[position] != rune('l') {
						goto l122
					}
					position++
					goto l121
				l122:
					position, tokenIndex = position121, tokenIndex121
					if buffer[position] != rune('N') {
						goto l119
					}
					position++
					if buffer[position] != rune('o') {
						goto l119
					}
					position++
					if buffer[position] != rune('n') {
						goto l119
					}
					position++
					if buffer[position] != rune('e') {
						goto l119
					}
					position++
				}
			l121:
				add(ruleNull, position120)
			}
			return true
		l119:
			position, tokenIndex = position119, tokenIndex119
			return false
		},
		/* 21 Number <- <(Minus? IntegralPart FractionalPart? ExponentPart?)> */
		func() bool {
			position123, tokenIndex123 := position, tokenIndex
			{
				position124 := position
				{
					position125, tokenIndex125 := position, tokenIndex
					if !_rules[ruleMinus]() {
						goto l125
					}
					goto l126
				l125:
					position, tokenIndex = position125, tokenIndex125
				}
			l126:
				if !_rules[ruleIntegralPart]() {
					goto l123
				}
				{
					position127, tokenIndex127 := position, tokenIndex
					if !_rules[ruleFractionalPart]() {
						goto l127
					}
					goto l128
				l127:
					position, tokenIndex = position127, tokenIndex127
				}
			l128:
				{
					position129, tokenIndex129 := position, tokenIndex
					if !_rules[ruleExponentPart]() {
						goto l129
					}
					goto l130
				l129:
					position, tokenIndex = position129, tokenIndex129
				}
			l130:
				add(ruleNumber, position124)
			}
			return true
		l123:
			position, tokenIndex = position123, tokenIndex123
			return false
		},
		/* 22 Minus <- <'-'> */
		func() bool {
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				if buffer[position] != rune('-') {
					goto l131
				}
				position++
				add(ruleMinus, position132)
			}
			return true
		l131:
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 23 IntegralPart <- <('0' / ([1-9] [0-9]*))> */
		func() bool {
			position133, tokenIndex133 := position, tokenIndex
			{
				position134 := position
				{
					position135, tokenIndex135 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l136
					}
					position++
					goto l135
				l136:
					position, tokenIndex = position135, tokenIndex135
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l133
					}
					position++
				l137:
					{
						position138, tokenIndex138 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l138
						}
						position++
						goto l137
					l138:
						position, tokenIndex = position138, tokenIndex138
					}
				}
			l135:
				add(ruleIntegralPart, position134)
			}
			return true
		l133:
			position, tokenIndex = position133, tokenIndex133
			return false
		},
		/* 24 FractionalPart <- <('.' [0-9]+)> */
		func() bool {
			position139, tokenIndex139 := position, tokenIndex
			{
				position140 := position
				if buffer[position] != rune('.') {
					goto l139
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l139
				}
				position++
			l141:
				{
					position142, tokenIndex142 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l142
					}
					position++
					goto l141
				l142:
					position, tokenIndex = position142, tokenIndex142
				}
				add(ruleFractionalPart, position140)
			}
			return true
		l139:
			position, tokenIndex = position139, tokenIndex139
			return false
		},
		/* 25 ExponentPart <- <(('e' / 'E') ('+' / '-')? [0-9]+)> */
		func() bool {
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				{
					position145, tokenIndex145 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l146
					}
					position++
					goto l145
				l146:
					position, tokenIndex = position145, tokenIndex145
					if buffer[position] != rune('E') {
						goto l143
					}
					position++
				}
			l145:
				{
					position147, tokenIndex147 := position, tokenIndex
					{
						position149, tokenIndex149 := position, tokenIndex
						if buffer[position] != rune('+') {
							goto l150
						}
						position++
						goto l149
					l150:
						position, tokenIndex = position149, tokenIndex149
						if buffer[position] != rune('-') {
							goto l147
						}
						position++
					}
				l149:
					goto l148
				l147:
					position, tokenIndex = position147, tokenIndex147
				}
			l148:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l143
				}
				position++
			l151:
				{
					position152, tokenIndex152 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l152
					}
					position++
					goto l151
				l152:
					position, tokenIndex = position152, tokenIndex152
				}
				add(ruleExponentPart, position144)
			}
			return true
		l143:
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 26 Spacing <- <(Whitespace / LongComment / LineComment / Pragma)*> */
		func() bool {
			{
				position154 := position
			l155:
				{
					position156, tokenIndex156 := position, tokenIndex
					{
						position157, tokenIndex157 := position, tokenIndex
						if !_rules[ruleWhitespace]() {
							goto l158
						}
						goto l157
					l158:
						position, tokenIndex = position157, tokenIndex157
						if !_rules[ruleLongComment]() {
							goto l159
						}
						goto l157
					l159:
						position, tokenIndex = position157, tokenIndex157
						if !_rules[ruleLineComment]() {
							goto l160
						}
						goto l157
					l160:
						position, tokenIndex = position157, tokenIndex157
						if !_rules[rulePragma]() {
							goto l156
						}
					}
				l157:
					goto l155
				l156:
					position, tokenIndex = position156, tokenIndex156
				}
				add(ruleSpacing, position154)
			}
			return true
		},
		/* 27 Whitespace <- <(' ' / '\t' / '\r' / '\n')+> */
		func() bool {
			position161, tokenIndex161 := position, tokenIndex
			{
				position162 := position
				{
					position165, tokenIndex165 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l166
					}
					position++
					goto l165
				l166:
					position, tokenIndex = position165, tokenIndex165
					if buffer[position] != rune('\t') {
						goto l167
					}
					position++
					goto l165
				l167:
					position, tokenIndex = position165, tokenIndex165
					if buffer[position] != rune('\r') {
						goto l168
					}
					position++
					goto l165
				l168:
					position, tokenIndex = position165, tokenIndex165
					if buffer[position] != rune('\n') {
						goto l161
					}
					position++
				}
			l165:
			l163:
				{
					position164, tokenIndex164 := position, tokenIndex
					{
						position169, tokenIndex169 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l170
						}
						position++
						goto l169
					l170:
						position, tokenIndex = position169, tokenIndex169
						if buffer[position] != rune('\t') {
							goto l171
						}
						position++
						goto l169
					l171:
						position, tokenIndex = position169, tokenIndex169
						if buffer[position] != rune('\r') {
							goto l172
						}
						position++
						goto l169
					l172:
						position, tokenIndex = position169, tokenIndex169
						if buffer[position] != rune('\n') {
							goto l164
						}
						position++
					}
				l169:
					goto l163
				l164:
					position, tokenIndex = position164, tokenIndex164
				}
				add(ruleWhitespace, position162)
			}
			return true
		l161:
			position, tokenIndex = position161, tokenIndex161
			return false
		},
		/* 28 LongComment <- <('/' '*' (!('*' '/') .)* ('*' '/'))> */
		func() bool {
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				if buffer[position] != rune('/') {
					goto l173
				}
				position++
				if buffer[position] != rune('*') {
					goto l173
				}
				position++
			l175:
				{
					position176, tokenIndex176 := position, tokenIndex
					{
						position177, tokenIndex177 := position, tokenIndex
						if buffer[position] != rune('*') {
							goto l177
						}
						position++
						if buffer[position] != rune('/') {
							goto l177
						}
						position++
						goto l176
					l177:
						position, tokenIndex = position177, tokenIndex177
					}
					if !matchDot() {
						goto l176
					}
					goto l175
				l176:
					position, tokenIndex = position176, tokenIndex176
				}
				if buffer[position] != rune('*') {
					goto l173
				}
				position++
				if buffer[position] != rune('/') {
					goto l173
				}
				position++
				add(ruleLongComment, position174)
			}
			return true
		l173:
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 29 LineComment <- <('/' '/' (!('\r' / '\n') .)* ('\r' / '\n'))> */
		func() bool {
			position178, tokenIndex178 := position, tokenIndex
			{
				position179 := position
				if buffer[position] != rune('/') {
					goto l178
				}
				position++
				if buffer[position] != rune('/') {
					goto l178
				}
				position++
			l180:
				{
					position181, tokenIndex181 := position, tokenIndex
					{
						position182, tokenIndex182 := position, tokenIndex
						{
							position183, tokenIndex183 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l184
							}
							position++
							goto l183
						l184:
							position, tokenIndex = position183, tokenIndex183
							if buffer[position] != rune('\n') {
								goto l182
							}
							position++
						}
					l183:
						goto l181
					l182:
						position, tokenIndex = position182, tokenIndex182
					}
					if !matchDot() {
						goto l181
					}
					goto l180
				l181:
					position, tokenIndex = position181, tokenIndex181
				}
				{
					position185, tokenIndex185 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l186
					}
					position++
					goto l185
				l186:
					position, tokenIndex = position185, tokenIndex185
					if buffer[position] != rune('\n') {
						goto l178
					}
					position++
				}
			l185:
				add(ruleLineComment, position179)
			}
			return true
		l178:
			position, tokenIndex = position178, tokenIndex178
			return false
		},
		/* 30 Pragma <- <('#' (!('\r' / '\n') .)* ('\r' / '\n'))> */
		func() bool {
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				if buffer[position] != rune('#') {
					goto l187
				}
				position++
			l189:
				{
					position190, tokenIndex190 := position, tokenIndex
					{
						position191, tokenIndex191 := position, tokenIndex
						{
							position192, tokenIndex192 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l193
							}
							position++
							goto l192
						l193:
							position, tokenIndex = position192, tokenIndex192
							if buffer[position] != rune('\n') {
								goto l191
							}
							position++
						}
					l192:
						goto l190
					l191:
						position, tokenIndex = position191, tokenIndex191
					}
					if !matchDot() {
						goto l190
					}
					goto l189
				l190:
					position, tokenIndex = position190, tokenIndex190
				}
				{
					position194, tokenIndex194 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l195
					}
					position++
					goto l194
				l195:
					position, tokenIndex = position194, tokenIndex194
					if buffer[position] != rune('\n') {
						goto l187
					}
					position++
				}
			l194:
				add(rulePragma, position188)
			}
			return true
		l187:
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 31 LWING <- <('{' Spacing)> */
		func() bool {
			position196, tokenIndex196 := position, tokenIndex
			{
				position197 := position
				if buffer[position] != rune('{') {
					goto l196
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l196
				}
				add(ruleLWING, position197)
			}
			return true
		l196:
			position, tokenIndex = position196, tokenIndex196
			return false
		},
		/* 32 RWING <- <('}' Spacing)> */
		func() bool {
			position198, tokenIndex198 := position, tokenIndex
			{
				position199 := position
				if buffer[position] != rune('}') {
					goto l198
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l198
				}
				add(ruleRWING, position199)
			}
			return true
		l198:
			position, tokenIndex = position198, tokenIndex198
			return false
		},
		/* 33 LBRK <- <('[' Spacing)> */
		func() bool {
			position200, tokenIndex200 := position, tokenIndex
			{
				position201 := position
				if buffer[position] != rune('[') {
					goto l200
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l200
				}
				add(ruleLBRK, position201)
			}
			return true
		l200:
			position, tokenIndex = position200, tokenIndex200
			return false
		},
		/* 34 RBRK <- <(']' Spacing)> */
		func() bool {
			position202, tokenIndex202 := position, tokenIndex
			{
				position203 := position
				if buffer[position] != rune(']') {
					goto l202
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l202
				}
				add(ruleRBRK, position203)
			}
			return true
		l202:
			position, tokenIndex = position202, tokenIndex202
			return false
		},
		/* 35 COMMA <- <(',' Spacing)> */
		func() bool {
			position204, tokenIndex204 := position, tokenIndex
			{
				position205 := position
				if buffer[position] != rune(',') {
					goto l204
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l204
				}
				add(ruleCOMMA, position205)
			}
			return true
		l204:
			position, tokenIndex = position204, tokenIndex204
			return false
		},
		/* 36 COLON <- <(':' Spacing)> */
		func() bool {
			position206, tokenIndex206 := position, tokenIndex
			{
				position207 := position
				if buffer[position] != rune(':') {
					goto l206
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l206
				}
				add(ruleCOLON, position207)
			}
			return true
		l206:
			position, tokenIndex = position206, tokenIndex206
			return false
		},
		/* 37 EOT <- <!.> */
		func() bool {
			position208, tokenIndex208 := position, tokenIndex
			{
				position209 := position
				{
					position210, tokenIndex210 := position, tokenIndex
					if !matchDot() {
						goto l210
					}
					goto l208
				l210:
					position, tokenIndex = position210, tokenIndex210
				}
				add(ruleEOT, position209)
			}
			return true
		l208:
			position, tokenIndex = position208, tokenIndex208
			return false
		},
	}
	p.rules = _rules
	return nil
}
